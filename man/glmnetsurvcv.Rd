% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/glmnetpostsurv.R
\name{glmnetsurvcv}
\alias{glmnetsurvcv}
\title{Cross-validation for glmnet survival models via glmnetsurv}
\usage{
glmnetsurvcv(
  formula = formula(data),
  data = sys.parent(),
  family = "cox",
  alpha = 1,
  lambda = NULL,
  nfolds = 10,
  foldid = NULL,
  refit = TRUE,
  contrasts.arg = NULL,
  xlevs = NULL,
  na.action = na.omit,
  ...
)
}
\arguments{
\item{formula}{Object of class formula describing 
the model. The response and terms are specified 
similar to \code{\link[survival]{Surv}} function.}

\item{data}{optional data frame containing 
variables specified in the formula.}

\item{family}{currently, only \code{glmnet} \code{"cox"} family (survival model) is allowed.}

\item{alpha}{elasticnet mixing parameter, with
\code{0 <= alpha <= 1}. If a vector of  \code{alpha} is supplied, cross-validation will be performed for each of the \code{alpha} and optimal value returned. The default is \code{1}.}

\item{lambda}{optional user supplied lambda sequence, \code{\link[glmnet]{cv.glmnet}}.}

\item{nfolds}{number of folds. Default is \code{10}.}

\item{foldid}{an optional sequence of values between \code{1} and {nfolds} specifying what fold each observation is in. This is important when comparing performance across models. If specified, \code{nfolds} can be missing.}

\item{refit}{logical. Whether to return solution path based on optimal lambda and alpha picked by the model. Default is \code{refit = TRUE}.}

\item{contrasts.arg}{an optional list. See 
the contrasts.arg of
\code{[stats]{model.matrix.default}}.}

\item{xlevs}{a named list of character vectors 
giving the full set of levels to be assumed 
for each factor. See \code{[stats]{model.frame}}.}

\item{na.action}{a function which indicates 
what should happen when the data contain NAs. 
See \code{[stats]{model.frame}}.}

\item{...}{any of the options in \code{\link[glmnet]{cv.glmnet}}.}
}
\value{
An S3 object of class \code{\link[glmnetsurv]{glmnetsurvcv}}:
\item{lambda.min}{the value of lambda that gives minimum cross-validated error.}
\item{lambda.1se}{largest value of lambda such that error is within \code{1} standard error of the minimum.}
\item{alpha.optimal}{optimal alpha corresponding to \code{lambda.min}.}
\item{lambdas.optimal}{the sequence of lambdas containing \code{lambda.min}.}
\item{foldids}{the fold assignment used.}
\item{dfs}{list of data frames containing mean cross-validated error summaries and estimated coefficients in each fold.}
\item{fit}{if \code{refit = TRUE}, summaries corresponding to the optimal \code{alpha} and \code{lambdas}. This is used to plot solution path}.
}
\description{
Performs \code{k}-fold cross-validation for \code{\link[glmnet]{glmnet}} via \code{\link[glmnetsurv]{glmnetsurvcv}}, plots
solution path plots, and returns optimal value of lambda
(and optimal alpha if more than one is given).
}
\details{
Performs cross-validation as illustrated in \code{\link[glmnet]{cv.glmnet}} but has additional capability to support more than one \code{alpha}.

If more than one \code{alpha} is specified, say code{(0.2, 0.5, 1)}, the \code{glmnetsurvcv} will search for optimal values for alpha with respect to the corresponding lambda values. In this case, optimal alpha and lambda sequence will be returned, i.e., the \code{(alpha, lambda)} pair that corresponds to the lowest predicted cross-validated error (likelihood deviance).
}
\examples{

data(veteran, package="survival")
cv1 <- glmnetsurvcv(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, alpha = 1
	, refit = FALSE
)
print(cv1)

# Train model using optimal alpha and lambda
fit1 <- glmnetsurv(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, alpha = cv1$alpha.optimal
	, lambda = cv1$lambda.min
)
print(fit1)

}
\seealso{
\code{\link[glmnetsurv]{plot.glmnetsurvcv}}, \code{\link[glmnetsurv]{glmnetsurvcv}}, \code{\link[glmnet]{cv.glmnet}}
}
